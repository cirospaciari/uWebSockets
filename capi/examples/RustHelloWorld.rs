/* automatically generated by rust-bindgen 0.59.2 */
use std::convert::TryInto;

pub type SizeT = ::std::os::raw::c_ulong;
pub type WcharT = ::std::os::raw::c_uint;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce1 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce2 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uws_app_s {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uws_req_s {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uws_res_s {
    _unused: [u8; 0],
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uws_app_listen_config_s {
    port: ::std::os::raw::c_int,
    host: *const ::std::os::raw::c_char,
    options: ::std::os::raw::c_int,
}
pub type UwsAppListenConfigT = uws_app_listen_config_s;

pub type UwsAppT = uws_app_s;
pub type UwsReqT = uws_req_s;
pub type UwsResT = uws_res_s;
extern "C" {
    pub fn uws_create_app() -> *mut UwsAppT;
    pub fn uws_app_get(
        app: *mut UwsAppT,
        pattern: *const ::std::os::raw::c_char,
        handler: ::std::option::Option<
            unsafe extern "C" fn(
                res: *mut UwsResT,
                req: *mut UwsReqT,
                user_data: *mut ::std::os::raw::c_void,
            ),
        >,
        user_data: *mut ::std::os::raw::c_void,
    );
    pub fn uws_app_run(arg1: *mut UwsAppT);

    pub fn uws_app_listen(
        app: *mut UwsAppT,
        port: ::std::os::raw::c_int,
        handler: ::std::option::Option<
            unsafe extern "C" fn(
                listen_socket: *mut ::std::os::raw::c_void,
                config: UwsAppListenConfigT,
                user_data: *mut ::std::os::raw::c_void,
            ),
        >,
        user_data: *mut ::std::os::raw::c_void,
    );
    pub fn uws_res_end(
        res: *mut UwsResT,
        data: *const ::std::os::raw::c_char,
        length: SizeT,
        close_connection: bool,
    );
}

pub struct AppResponse {
    native: *mut UwsResT,
}
pub struct AppRequest {
    native: *mut UwsReqT,
}
impl AppRequest {
    pub fn new(native: *mut UwsReqT) -> AppRequest {
        AppRequest { native: native }
    }
}
impl AppResponse {
    pub fn new(native: *mut UwsResT) -> AppResponse {
        AppResponse { native: native }
    }
    fn end(self, message: &str) -> AppResponse {
        unsafe {
            let c_message = ::std::ffi::CString::new(message).expect("Failed to create message CString");
            uws_res_end(
                self.native,
                c_message.as_ptr(),
                message.len().try_into().unwrap(),
                false,
            );
        }
        self
    }
}

pub type UwsMethodHandler = fn(res: AppResponse, req: AppRequest);
pub type UwsListenHandler =
    fn(listen_socket: *mut ::std::os::raw::c_void, config: UwsAppListenConfigT);

pub struct App {
    native: *mut UwsAppT,
}

extern "C" fn uws_generic_listen_handler(
    listen_socket: *mut ::std::os::raw::c_void,
    config: UwsAppListenConfigT,
    user_data: *mut ::std::os::raw::c_void,
) {
    unsafe {
        let callback = &mut *(user_data as *mut UwsListenHandler);
        callback(listen_socket, config);
    }
}

extern "C" fn uws_generic_method_handler(
    res: *mut UwsResT,
    req: *mut UwsReqT,
    user_data: *mut ::std::os::raw::c_void,
) {
    unsafe {
        let response = AppResponse::new(res);
        let request = AppRequest::new(req);
        let callback = &mut *(user_data as *mut UwsMethodHandler);
        callback(response, request);
    }
}

impl App {
    pub fn new() -> App {
        unsafe {
            App {
                native: uws_create_app(),
            }
        }
    }
    pub fn get(self, route: &str, mut handler: UwsMethodHandler) -> App {
        unsafe {
            let c_route = ::std::ffi::CString::new(route).expect("Failed to create route CString");

            uws_app_get(
                self.native,
                c_route.as_ptr(),
                ::std::option::Option::Some(uws_generic_method_handler),
                &mut handler as *mut _ as *mut ::std::os::raw::c_void,
            );
        }
        self
    }

    pub fn listen(self, port: i32, mut handler: UwsListenHandler) -> App {
        unsafe {
            uws_app_listen(
                self.native,
                port,
                ::std::option::Option::Some(uws_generic_listen_handler),
                &mut handler as *mut _ as *mut ::std::os::raw::c_void,
            );
        }
        self
    }

    pub fn run(self) -> App {
        unsafe {
            uws_app_run(self.native);
        }
        self
    }
}

fn main() {
    App::new()
        .get("/", |res, _req| {
            res.end("Hello Rust!");
        })
        .listen(3000, |_listen_socket, config| {
            println!("Listening on port http://127.0.0.1:{}", config.port);
        })
        .run();
}
